
FieldGroupSelectNestedJavaBeans.beanItemContainerInfo  = Diese Selektionskomponente verwendet einen <strong>com.vaadin.data.util.BeanItemContainer</strong> als Container Data Source.
FieldGroupSelectNestedJavaBeans.beanItemContainerTab   = Container Data Source des Department-Selektors: BeanItemContainer
FieldGroupSelectNestedJavaBeans.department             = Abteilung
FieldGroupSelectNestedJavaBeans.description            = Dieses Demo zeigt, wie man eine FieldGroup konfiguriert, mit der man eine von einer Entity Bean referenzierte JavaBean mit einer Selektionskomponente ausw\u00E4hlt. In diesem Beispiel gibt es eine Entity Bean 'Employee', die eine JavaBean Property 'Department' enth\u00E4lt. Mit den beiden Eingabeformularen, die auf den beiden Registerkarten zu sehen sind, kann man neue Employee Objekte in die \u00DCbersichtstabelle einf\u00FCgen. Das erste Formular verwendet zur Selektion der Abteilung einen BeanItemContainer als Container Data Source der Selektionskomponente. Das zweite Formular verwendet einen IndexedContainer als Datenmodell. Damit diese zweite FieldGroup funktioniert, ist es notwendig, dass man einen speziellen Converter auf der Selektionskomponente setzt, der zwischen Item ID und Department-Objekt konvertiert. Nat\u00FCrlich verhalten sich beide Eingabeformulare genau gleich, was ja auch der Sinn dieses Tutorials ist. Der Unterschied zwischen den beiden Formularen ist nur im Code sichtbar.
FieldGroupSelectNestedJavaBeans.firstname              = Vorname
FieldGroupSelectNestedJavaBeans.indexedContainerInfo   = Diese Selektionskomponente verwendet einen <strong>com.vaadin.data.util.IndexedContainer</strong> als Container Data Source.
FieldGroupSelectNestedJavaBeans.indexedContainerTab    = Container Data Source des Department-Selektors: IndexedContainer
FieldGroupSelectNestedJavaBeans.lastname               = Nachname
FieldGroupSelectNestedJavaBeans.shortDescription       = Dieses Demo zeigt, wie man mit einer FieldGroup eine von einer Entity Bean referenzierte JavaBean mit einer Selektionskomponente ausw\u00E4hlt. Es werden zwei verschiedene Container-Implementierungen als Datenquelle der Selektionskomponente verwendet.
FieldGroupSelectNestedJavaBeans.validationerrormessage = Eingabe kann nicht \u00FCbernommen werden. Haben Sie alle erforderlichen Felder ausgef\u00FCllt?
FieldGroupSelectNestedJavaBeans.validationfailed       = Validierung fehlgeschlagen

UsingSessionAndUIScope.activeUIobjects     = In dieser Session (Session ID <em>{1}</em>) sind momentan {0} UI Objekte aktiv.
UsingSessionAndUIScope.currentUIsID        = ID des aktuellen UI Objekts: 
UsingSessionAndUIScope.editVariables       = Definieren Sie hier Variablen mit Session- oder UI-Sichtbarkeit:
UsingSessionAndUIScope.headline            = Verwendung von Vaadins Session- und UI-Sichtbarkeitsbereichen
UsingSessionAndUIScope.openThisApplication = \u00D6ffnen Sie dieses Beispiel in einem neuen Browserfenster/-tab <a href="#!{0}" target="_blank">mit diesem Link</a>, und aktualisieren Sie das Browserfenster nachdem Sie die Variablen mit den unterschiedlichen Sichtbarkeitsbereichen editiert haben.
UsingSessionAndUIScope.overviewHeadline    = <h2>\u00DCbersicht \u00FCber alle Variablen mit UI-Sichtbarkeitsbereich der aktuellen Session</h2>
UsingSessionAndUIScope.sessionScopedValue  = Wert mit Session-Sichtbarkeit:
UsingSessionAndUIScope.shortDescription    = Dieses Beispiel demonstriert die beiden Sichtbarkeitsbereiche einer Vaadin 7 Session. Dies sind der normale Session-Scope und der neue UI-Scope. Der UI-Scope enth\u00E4lt s\u00E4mtliche Daten, die f\u00FCr den Inhalt eines einzelnen Browserfensters oder -tabs in einer Session ben\u00F6tigt werden. In diesem Demo k\u00F6nnen Sie jeweils eine Variable mit Session-Scope und eine Variable mit UI-Scope editieren. Es wird dann gezeigt, dass f\u00FCr jedes neue Browserfenster, das aus der gleichen Session ge\u00F6ffnet wird, ein neues UI Objekt erzeugt wird, das seine eigene Version der Variable mit UI-Scope enth\u00E4lt.
UsingSessionAndUIScope.uiScopedValue       = Wert mit UI-Sichtbarkeit:

aboutText = <p>Die Vaadin-By-Example Demoanwendung wird von mir, Roland Kr\u00FCger, entwickelt und gepflegt. Diese Awendung soll als Spielwiese dienen, um funktionierenden Beispielcode zur Verf\u00FCgung zu stellen, der meine Blogeintr\u00E4ge \u00FCber Vaadin und meine Vaadin Addons begleitet. Die Anwendung wird mit der Zeit entsprechend mit neuen Demos erweitert, wenn ich meine n\u00E4chsten Blog Posts \u00FCber Vaadin oder neue Vaadin Addons ver\u00F6ffentliche.</p>\r\n\r\n<h2>\u00DCber mich</h2>\r\n<p>Ich arbeite als Trainer, Berater und Entwickler f\u00FCr die <a href="http://www.oio.de" target="_blank">Orientation in Objects GmbH</a> in Mannheim. Ich schreibe regelm\u00E4\u00DFig \u00FCber Vaadin und Java-bezogene Themen in unserem <a href="http://blog.oio.de/author/rolandkrueger/" target="_blank">Firmenblog</a>. Um die Blogeintr\u00E4ge, die ich \u00FCber Vaadin schreibe, mit einfachem Beispielcode erg\u00E4nzen zu k\u00F6nnen, habe ich das GitHub Repository <a href="https://github.com/rolandkrueger/vaadin-by-example" target="_blank">vaadin-by-example</a> angelegt. Die vorliegende Anwendung vereint die meisten dieser Beispiele in einer gro\u00DFen Demoanwendung.</p>\r\n\r\n<p>Sie finden mich auf <a href="https://twitter.com/Roland_Krueger" target="_blank">Twitter</a>, <a href="https://plus.google.com/107390769372631613806" target="_blank">Google+</a> und <a href="https://github.com/rolandkrueger" target="_blank">Github</a>.</p>\r\n\r\n<h2>Credits</h2>\r\n<p>Die in dieser Anwendung verwendeten Icons stammen von <a href="http://www.famfamfam.com">Mark James</a> und <a href="http://glyphicons.com/">Glyphicons</a>. Die Hintergrundgrafiken stammen von <a href="http://www.backgroundlabs.com" title="Background Labs">Background Labs</a>.</p>

componentHighlighter.description      = <ul>\r\n    <li><a href="?debug#!/demo/ComponentHighlighterDemo">Highlighting Labels einschalten</a></li>\r\n    <li><a href="?debug=quiet#!/demo/ComponentHighlighterDemo">Labels einschalten, aber die Debug-Konsole verstecken</a></li>\r\n    <li><a href="?#!/demo/ComponentHighlighterDemo">Labels ausschalten</a></li>\r\n</ul>\r\n\r\n<p>Die Aufgabe des Component Highlighter Addons ist es, den Vaadin Entwickler beim Schreiben einer Vaadin-Anwendung zu unterst\u00FCtzen. Das Addon stellt eine Extension-Klasse f\u00FCr Komponenten zur Verf\u00FCgung, die eine Komponente im Browser mit einem auff\u00E4lligen Label hervorhebt. Das Label enth\u00E4lt den vollqualifizierten Klassennamen der erweiterten Komponente und/oder einen vom Entwickler festgelegten Text. Dadurch wird sofort im Browser sichtbar, welcher Teil einer Benutzeroberfl\u00E4che von welcher Java-Klasse implementiert wird. Die Erweiterung ist nur dann aktiv, wenn die Vaadin-Anwendung im Debug-Modus betrieben wird. Im Produktions-Modus hat das Addon keine Auswirkung. Eine typische Anwendung f\u00FCr das Addon zeigt der folgende Code:</p>\r\n\r\n<pre class="sourcecode">\r\npublic class MyComponent extends CustomComponent {\r\n    ...\r\n    public MyComponent() {\r\n        super();\r\n        new ComponentHighlighterExtension(this);\r\n        ...\r\n    }\r\n}</pre>\r\n\r\n<p>Hier wird im Konstruktor der CustomComponent eine neue lokale Instanz der Highlighter Extension erzeugt. Das CustomComponent Objekt wird im Konstruktor der ComponentHighlighterExtension nur dann mit extend() modifiziert, wenn die Anwendung im Debug-Modus betrieben wird. Aus diesem Grund muss man nicht selbst den Modus abfragen, in dem die Anwendung betrieben wird, wenn man neue lokale Instanzen der Extension erzeugt. Im Produktions-Modus wird extend() einfach nicht aufgerufen, so dass lokale Instanzen der Extension gleich wieder vom Garbage Collector entsorgt werden und kein Heap-Speicher verschwendet wird.</p>\r\n\r\n<p>Die Labels, die bestimmte Komponenten hervorheben, sind in der laufenden Anwendung im normalen Modus nicht sichtbar. Die Labels k\u00F6nnen aktiviert und sichtbar gemacht werden, indem man Vaadins Debug Modus mit dem <span class="code">debug</span> URL Parameter einschaltet. Dieser Parameter \u00F6ffnet \u00FCblicherweise die Debug-Konsole von Vaadin. Wenn man eine Komponente in einer Anwendung mit dem ComponentHighlighter Addon erweitert hat, wird diese Komponente nun im Browser hervorgehoben.</p>\r\n\r\n<p>Diese Demoanwendung macht intensiven Gebrauch von dem Addon. Mit den folgenden Links k\u00F6nnen Sie die Highlighter-Labels ein- und ausschalten. Das funktioniert, da diese Demoapplikation im Debug-Modus betrieben wird. Die Labels dekorieren dann das DIV einer erweiterten Komponente und zeigen den Klassennamen der Komponente an.</p>\r\n\r\n<h2>Verwendung</h2>\r\n<p>Um dieses Addon in einem eigenen Projekt zu verwenden, m\u00FCssen Sie von dem GWT Modul des Addons in Ihrem eigenen Widgetset-Deskriptor erben:</p>\r\n\r\n<pre>\r\n&lt;module&gt;\r\n    &lt;inherits name="com.vaadin.DefaultWidgetSet" /&gt;\r\n    &lt;inherits name="org.vaadin.highlighter.ComponentHighlighterWidgetset" /&gt;\r\n&lt;/module&gt;\r\n</pre>\r\n\r\n<p>Das <a href="https://vaadin.com/book" target="_blank">Book of Vaadin</a> beschreibt ausf\u00FChrlich alle notwendigen Schritte, um ein Vaadin Addon in einem Projekt hinzuzuf\u00FCgen und ein eigenes Widgetset zu kompilieren.</p>
componentHighlighter.headline         = Das Component Highlighter-Addon
componentHighlighter.shortDescription = Vaadin Addon, mit dem man eine Vaadin-Komponente optisch hervorheben und mit einem Label beschreiben kann, wenn die Anwendung im Debug-Modus betrieben wird.

demoselection.description = <p>Die folgenden Demos stehen zur Verf\u00FCgung:</p>

home.description = <p>Willkommen auf der Demo-Anwendung f\u00FCr das <a href="https://github.com/rolandkrueger/vaadin-by-example" target="_blank">vaadin-by-example GitHub Repository</a>. Diese Anwendung zeigt funktionierende Beispiele f\u00FCr einen Gro\u00DFteil der Beispielprojekte in dem GitHub Repository. Daneben dient die Anwendung als Demo-Anwendung f\u00FCr die Vaadin Addons, die <a href="#!/about">ich</a> im Vaadin Directory zur Verf\u00FCgung stelle. Sie k\u00F6nnen die einzelnen Demos <a href="#!/demos">besuchen</a> und bekommen auf der jeweiligen Demoseite zus\u00E4tzliche Informationen \u00FCber das Beispiel.</p>\r\n\r\n<h2>\u00DCber die Demo-Anwendung</h2>\r\n<p>Der Sourcecode f\u00FCr diese Demoanwendung selbst steht Ihnen ebenfalls in dem <a href="https://github.com/rolandkrueger/vaadin-by-example/tree/master/all-in-one-demo" target="_blank">vaadin-by-example GitHub Repository</a> zur Verf\u00FCgung. Sie k\u00F6nnen den Code auschecken und die Demoanwendung lokal mit dem <a href="http://maven.apache.org/" target="_blank">Maven Build Tool</a> laufen lassen. Dazu m\u00FCssen Sie blo\u00DF den folgenden Kommandozeilenbefehl in dem ausgecheckten Projektverzeichnis ausf\u00FChren, wenn Sie den <span class="code">mvn</span> Befehl in Ihrer <span class="code">PATH</span> Variable haben:</p>\r\n\r\n<p class="sourcecode">$ mvn package jetty:run</p>\r\n\r\n<p>Die Demoanwendung verwendet intern das <a href="http://www.springsource.org/" target="_blank">Spring Framework</a> und das <a href="http://projectlombok.org" target="_blank">Lombok-Projekt</a>. Zus\u00E4tzlich wird meine Bibliothek <a href="https://github.com/rolandkrueger/AppBaseForVaadin" target="_blank">AppBaseForVaadin</a> eingesetzt, die ein allgemeines Framework f\u00FCr Dienste zur Verf\u00FCgung stellt, die man in einer Web-Anwendung \u00FCblicherweise immer wieder ben\u00F6tigt (z.B. einen Event Bus, Templating f\u00FCr die Internationalisierung (mit Apache Velocity) oder Seitennavigation).</p>\r\n\r\n<h2>Lizensierung</h2>\r\n<p>Der Quellcode f\u00FCr diese Demoanwendung ist unter der MIT Lizenz lizensiert.</p>

i18nForCustomLayoutsUsingVelocity.description      = <p>Dieses Demo verwendet die Apache Velocity Templating Engine, um s\u00E4mtliche verwendete CustomLayout Templates zu \u00FCbersetzen. Die Demobeschreibung, die Sie gerade lesen, wird in einem Java Resource Bundle \u00FCbersetzt und verwaltet. Das trifft auch auf alle anderen \u00FCbersetzten Texte dieser Anwendung zu. Sie k\u00F6nnen die angezeigte Sprache rechts oben in der Sprachselektion \u00E4ndern.</p>\r\n\r\n<p>Die Templatedateien, die zur Instantiierung der CustomLayouts verwendet werden, enthalten Referenzen auf die \u00DCbersetzungsschl\u00FCssel, die in den Resource Bundles definiert werden. Sie k\u00F6nnen z.B. einmal einen Blick <a href="VAADIN/themes/demo/layouts/main.html" target="_blank">auf die Vorlage</a> f\u00FCr die Hauptseite werfen (\u00F6ffnen Sie die Source View f\u00FCr diese Seite, um die Dokumentenstruktur zu sehen).</p>\r\n\r\n<p>Beachten Sie, dass dieses Demo einen etwas anderen Ansatz verwendet, als in dem begleitenden Blog Post beschrieben wird. Da diese Anwendung das Spring Framework verwendet, wird die Velocity Engine von Spring erzeugt und in eine entsprechende Serviceklasse injiziert. Zudem verwendet dieser Ansatz nicht das Resource Tool von Velocity, sondern greift stattdessen auf die MessageSource Klasse von Spring zur\u00FCck, um auf die einzelnen \u00DCbersetzungen w\u00E4hrend des Templating-Prozesses zuzugreifen. Sie finden die Implementierung f\u00FCr diesen Anatz in der Serviceklasse <a href="https://github.com/rolandkrueger/AppBaseForVaadin/blob/master/src/main/java/org/vaadin/appbase/service/templating/impl/TemplatingService.java">TemplatingService</a>.</p>
i18nForCustomLayoutsUsingVelocity.headline         = Internationalisierung von CustomLayouts mit Apache Velocity
i18nForCustomLayoutsUsingVelocity.shortDescription = Dieses Beispiel demonstriert, wie Vaadin CustomLayout Templates mit dem Apache Velocity Template Engine lokalisiert werden k\u00F6nnen. Damit ist es m\u00F6glich, statischen Text, der in CustomLayouts verwendet wird, in die Locale des Anwenders zu \u00FCbersetzen.
